### 기간 : 2022.01.28(금) ~ 2022.02.05.(토)

---

## 자료구조, 알고리즘

- [힙](#힙-heap)
- [정렬](#정렬-sorting)
  - 버블 정렬
  - 선택 정렬
  - 삽입 정렬
  - 퀵 정렬
  - 병합 정렬
  - 힙 정렬
- [이진 탐색](#이진-탐색-binary-search)

---

<br>

### 힙 Heap

> 힙의 특성을 만족하는 거의 완전한 트리인 특수한 트리 기반의 자료 구조
>
> - 최소 힙(Min Heap) : 부모가 항상 자식보다 작거나 같다
> - 최대 힙(Max Heap) : 부모가 항상 자식보다 크거나 같다
>
> ---
>
> - 힙은 정렬된 구조가 아니다 : 부모와 자식의 관계에서 조건이 있을 뿐, 좌우에 대한 관계는 정의하지 않는다
> - 활용 : 우선순위 큐, 다익스트라 알고리즘
> - 배열로 구현할 때, 0번 인덱스를 비우고 1번 인덱스부터 시작하면 부모 노드와 자식 노드의 인덱스는 다음과 같은 관계를 가진다.
>   > `부모 : i, 자식 : 2i(왼), 2i + 1(오)`
>
> ---

### 힙 연산

> #### 삽입 : 시간복잡도 `O(log n)`
>
> > 1.  요소를 가장 마지막에 삽입한다(가장 하위 레벨의 최대한 왼쪽)
> > 1.  부모 값과 비교해 값이 더 작은 경우 위치를 변경한다(최소 힙)
> > 1.  계속해서 부모 값과 비교해 위치를 변경한다
>
> #### 추출 : 시간복잡도 `O(log n)`
>
> > 1.  루트를 추출하고, 가장 마지막 요소를 루트에 넣어준다
> > 1.  자식 값과 비교해 값이 더 큰 경우 위치를 변경한다(최소 힙)
> > 1.  계속해서 자식 값과 비교해 위치를 변경한다
>
> ---

#### 파이썬의 heapq 모듈

> - 최소 힙으로 구현되어 있다
> - 추출 : `heapq.heappush()`
> - 삽입 : `heapq.heappop()`
> - 기존의 리스트 -> 힙 : `heapq.heapify(list)`

<br>

---

<br>

### 정렬 Sorting

#### 버블 정렬 Bubble Sort

> - 비효율적이고 구현이 가장 느린 정렬 알고리즘
> - 바로 앞뒤 관계를 한칸씩 비교해서 스왑하며 for문 한바퀴를 돌 때마다 물 속에서 공기방울이 위로 올라가는 것처럼 가장 큰 값이 가장 마지막으로 이동하는 정렬

#### 선택 정렬 Selection Sort

> - 가장 작은 값을 찾아서 맨 앞과 스왑, 그 다음 작은 값을 찾아서 그 2번째와 스왑하는 방식으로 정렬

#### 삽입 정렬 Insertion Sort

> - 0번 인덱스의 값이 정렬이 되어 있다는 가정 하에 다음 인덱스 값부터 삽입하는 방식으로 정렬
> - 바로 이전의 값보다 삽입하는 값이 클 경우 바로 삽입, 작을 경우 한 칸씩 앞으로 이동하며 비교하며 자기 자리까지 찾아가며 정렬
> - 필요할 때만 위치를 변경하므로 선택 정렬보다 더 효율적인 방식

#### 퀵 정렬 Quick Sort

> - 피벗(pivot)이라고 하는 기준점을 둔다 (방식에 따라 0번 인덱스, 혹은 마지막 인덱스를 pivot으로 설정한다)
> - 포인터를 이동하며 피벗의 값과 비교하고 스왑해서 한바퀴를 돌고나면 피벗을 기준으로 왼쪽은 피벗보다 작은 값, 오른쪽은 피벗보다 큰 값으로 정렬이 된다
> - 나누어진 왼쪽과 오른쪽을 똑같은 방식으로 정렬해 나간다
> - 매우 빠르며 효율적인 알고리즘이다. 그러나 `최악의 경우(이미 정렬된 배열일 경우) 시간복잡도는 O(n^2)`이 된다.
> - 불안정 정렬

#### 병합 정렬 Merge Sort

> - 최선과 최악 모두 `O(n log n)`
> - 대부분의 경우 퀵 정렬보다 느리지만, 일정한 실행 속도, 안정 정렬
> - 가운데 인덱스를 기준으로 분할을 반복한다
> - 가장 작은 단위로 나누어지면 정렬을 하며 다시 병합한다
> - 병합할 때, 병합하는 두 배열을 앞에서부터 확인하며 작은 값부터 넣어서 정렬한다

#### 힙 정렬 Heap Sort

- [힙](#힙)

### 이진 탐색 Binary Search

> - 정렬된 배열에서 타겟을 찾는 검색 알고리즘
> - 시간복잡도 `O(log n)` : 탐색 범위를 1/2씩 줄이며 탐색해나간다
> - while문, 재귀로 구현
>   > - 찾고자 하는 답의 최소값과 최대값을 정한다
>   > - 최소값과 최대값의 가운데값을 구해 원하는 값인지 확인한다
>   > - 원하는 값보다 클 경우 최대값을 가운데값으로 변경한다
>   > - 원하는 값보다 작을 경우 최소값을 가운데값으로 변경한다
>   > - 원하는 답을 구할 때까지 반복해서 탐색한다
>
> ---
>
> - 파이썬 bisect 모듈 (특성을 고려한 조건을 사용해 값을 찾아야 한다)
>   > - `bisect.bisect_left(list, target)`
>   > - `bisect.bisect_right(list, target)`

---

```
안정 정렬 / 불안정 정렬
정렬을 했을 때, 입력값이 유지되느냐 유지되지 않느냐
```
