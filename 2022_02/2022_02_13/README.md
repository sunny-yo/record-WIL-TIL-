### 기간 : 2022.02.04(금) ~ 2022.02.12.(토)

---

## 자료구조, 알고리즘

- [이진 탐색 Binary Search](#이진-탐색-binary-search)
- [최단 경로](#최단-경로)
  - 다익스트라 알고리즘
  - 플로이드 워셜 알고리즘
- [다이나믹 프로그래밍 Dynamic Programming](#다이나믹-프로그래밍-dynamic-programming)

## React

- redux
- firebase firestore

---

<br>

### 이진 탐색 Binary Search

> - 정렬된 배열에서 타겟을 찾는 검색 알고리즘
> - 시간복잡도 `O(log n)` : 탐색 범위를 1/2씩 줄이며 탐색해나간다
> - while문, 재귀로 구현
>   > - 찾고자 하는 답의 최소값과 최대값을 정한다
>   > - 최소값과 최대값의 가운데값을 구해 원하는 값인지 확인한다
>   > - 원하는 값보다 클 경우 최대값을 가운데값으로 변경한다
>   > - 원하는 값보다 작을 경우 최소값을 가운데값으로 변경한다
>   > - 원하는 답을 구할 때까지 반복해서 탐색한다
>
> ---
>
> - 파이썬 bisect 모듈 (특성을 고려한 조건을 사용해 값을 찾아야 한다)
>   > - `bisect.bisect_left(list, target)`
>   > - `bisect.bisect_right(list, target)`

<br>

---

<br>

### 최단 경로

> ### 다익스트라 알고리즘
>
> > - 한 지점에서 다른 모든 지점까지의 최단 경로를 계산하는 알고리즘
> > - 노드 주변의 최단 경로만을 택한다(그리디 알고리즘 중 하나)
> > - 단순하고, 실행 속도 또한 빠르다
> > - BFS, 우선순위 큐
> >
> > ---
> >
> > 구현 방법(해당 지점까지의 최단 거리 찾기 부분)에 따른 시간복잡도 (V : 노드의 수, E : 간선의 수)
> >
> > 1.  for문 => `O(V^2)`
> > 2.  우선순위 큐(heap) => `O(E log V)`<br>
> >     => 확연한 차이가 드러날 때 : 노드의 개수는 많은데 간선의 개수가 적을 때
>
> <br>
>
> ### 플로이드 워셜 알고리즘
>
> > - 모든 지점에서 다른 모든 지점까지 가는 최단 경로를 계산하는 알고리즘
> > - 시간복잡도 `O(V^3)`
> > - 컨셉 : 점화식
> >   D<sub>ab</sub> = min(D<sub>ab</sub> , D<sub>ak</sub> + D<sub>kb</sub>)

<br>

---

<br>

### 다이나믹 프로그래밍 Dynamic Programming

> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
>
> 1. 탑다운 : 큰 문제를 해결하기 위해 작은 문제를 호출한다 / 재귀함수로 구현
> 2. 보텀업 : 작은 문제부터 차근차근 정답을 도출한다 / 반복문으로 구현
>
> ---
>
> - 다이나믹 프로그래밍으로 풀 수 있는 문제
>   > 1.  큰 문제를 작은 문제로 나눌 수 있다.
>   > 2.  작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. <br>
>   >     → 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법
>
> ---
>
> - 메모이제이션 기법 (Memoization) : 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법, 캐싱(Caching)이라고도 한다 <br>
>   ⇒ 탑다운 방식에 국한되어 사용하는 표현
> - DP 테이블 : 보텀업 방식에서 사용되는 결과 저장용 리스트

<br>

---

<br>

파이썬에서 무한 설정

```python
int(1e9)
sys.maxsize
```
